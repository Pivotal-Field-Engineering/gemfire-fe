grammar Shell;

cmd: query | execute | svm | gp | predict | print | ls | rm | evaluate | vector | matrix | fft ;
query: queryId EQUALS QUERY LPAREN queryString RPAREN ;
execute: EXECUTE LPAREN queryId (COMMA queryArg)* RPAREN ;
svm: modelId EQUALS SVM LPAREN matrixId COMMA vectorId (COMMA CP EQUALS cpVar)? (COMMA CN EQUALS cnVar)? (COMMA K EQUALS kVar)? RPAREN ;
gp: modelId EQUALS GP LPAREN matrixId COMMA vectorId (COMMA LAMBDA EQUALS lambdaVar)? RPAREN ;
predict: PREDICT LPAREN modelId COMMA (vectorId|number) RPAREN ;
evaluate: evaluateId EQUALS EVALUATE LPAREN modelId COMMA regionName (COMMA fieldName)+ RPAREN ;
vector: vectorId EQUALS VECTOR LPAREN queryId COMMA fieldName (COMMA queryArgs)? RPAREN ;
matrix: matrixId EQUALS MATRIX LPAREN queryId COMMA fieldNames (COMMA queryArgs)? RPAREN ;
print: PRINT var ;
ls: LS ;
rm: RM var ; 
fft: matrixId EQUALS FFT LPAREN fftInputId COMMA fftDir COMMA fftNorm RPAREN ; 

fftInputId: IDENTIFIER ;
fftDir: FORWARD | INVERSE ;
fftNorm: STANDARD | UNITARY ;
queryArg: QUOTEDSTRING | NUMBER ;
queryArgs: LBRACKET queryArg (COMMA queryArg)* RBRACKET ;
fieldNames: LBRACKET fieldName (COMMA fieldName)* RBRACKET ;
cpVar: NUMBER ;
cnVar: NUMBER ;
kVar: NUMBER ;
lambdaVar: NUMBER ;
var: IDENTIFIER ;
evaluateId: IDENTIFIER ;
fieldName: IDENTIFIER ;
modelId: IDENTIFIER ;
queryId: IDENTIFIER ;
regionName: IDENTIFIER ;
matrixId: IDENTIFIER ;
vectorId: IDENTIFIER ;
kernelId: IDENTIFIER ;
queryString : QUOTEDSTRING ;
number: NUMBER;

FFT: 'fft';
FORWARD: 'forward';
INVERSE: 'inverse';
STANDARD: 'standard';
UNITARY: 'unitary';
GAUSS: 'gauss';
MATRIX: 'matrix';
VECTOR: 'vect';
EVALUATE: 'evaluate';
QUERYARGS: 'queryArgs';
MODEL: 'model';
FIELDS: 'fields';
REGION: 'region';
RM: 'rm';
LS: 'ls';
PRINT: 'print';
PREDICT: 'predict';
K: 'k';
LAMBDA: 'lambda';
GP: 'gp';
SVM: 'svm';
KERNEL: 'kernel';
CP: 'cp';
CN: 'cn';
QUERY: 'query';
EXECUTE: 'execute';

LBRACKET: '[' ;
RBRACKET: ']' ;
LPAREN : '(' ;
RPAREN : ')' ;
LBRACE : '{' ;
RBRACE : '}' ;
DBLQUOTES : '"' ;
COMMA : ',' ;
EQUALS : '=' ;
IDENTIFIER : [a-zA-Z][a-zA-Z0-9_.]* ;
DIGIT: [0-9] ;
NUMBER: DIGIT+ ('.' DIGIT+)? ;
QUOTEDSTRING : DBLQUOTES (~["])+? DBLQUOTES ;
WS :  [ \t\r\n\u000C]+ -> skip ;
